[["index.html", "PSLM Stories The PSLM Survey 0.1 This repository", " PSLM Stories Rabeez Riaz The PSLM Survey The Pakistan Social And Living Standards Measurement Survey (PSLM) is the most frequent and up-to-date demographic survey conducted in Pakistan with sufficient detail to allow interesting explorations through the data. The survey responses (microdate) are shared by the Pakistan Bureau of Statistics (PBS) in form of Stata files dta along with pdf questionnaires used for each year. The questionnaire changes over the years and sometimes even entire sections are removed/added. I have created scripts which clean and standardize the survey microdata. My goal is to provide an accessible dataset from where social scientists and analysts can start their actual work without having to worry about the very clunky structure of the raw data. The scripts go through the following steps for each section available in each year: Load dta file Rename columns from numeric codes into human-readable phrases I have chosen the phrases to ensure same questions (regardless of question number in survey) have same name across years adn to avoid and to avoid name conflicts for similar sounding questions. But they are still based on my opinions so I will include a mapping from my names to original codes - so anyone familiar with the PSLM questionnaire can use their own naming if they wish. Fix encoding issues (especially across years). For example for a single section in some years province will be kept as a text value for other - years it will be a number (thankfully the mapping is consistent and available in PBS reports) Convert columns into appropriate data types Add a column denoting the year for survey Save each section for each year in a separate csv file Things the scripts do not do: 1. Perform text cleaning (inconsistent cases, KP/KPK representing same province etc) 2. Imputing/removing missing values 3. Combining cleaned files into big files for a single year containing all sections (or similar thing for same sections across all years) My reason for not doing any of these is to not get in the way of analysts who will have different objectives/goals with their analyses. I want to preserve as much of the original data semantics as possible while removing unnecessary cleaning steps which they will have to repeat themselves for all files. 0.1 This repository The goal here is to have illustrative examples of loading and performing simple data cleaning or exploration which any analyst can follow and replicate. Another goal is to provide a few examples of more detailed and targeted analyses which are supposed to show how much easier it is to answer rich questions if the major hurdle of parsing/cleaning the dta files is already done. "],["the-household-roster.html", "1 The Household Roster", " 1 The Household Roster library(tidyverse) library(lubridate) library(scales) library(patchwork) I load the survey roster data for each year and combine it into a single tibble/dataframe for easy analysis. I have specified a few columns directly as the correct datatypes using the col_types argument and if I had a targetted analysis in mind I would have used cols_only to save time and memory. Then I manually fix inconsistent encoding in factor columns and set certain sentinel values to NA using information from the questionnaire pdf. I also create a has_spouse column which I will extensively use for the analysis as a simplification of marital status which usually contains other statuses like divorced, engaged etc. Similarly I make an age_group column to group analyses/plots later. There are parsing errors for some columns. I find it better to just choose the required columns for the analysis with cols_only and manually specify types for them then manually fix encoding issues. root_dir &lt;- &quot;C:/Users/R/Desktop/pslm/data_clean&quot; year_dirs &lt;- head(list.dirs(root_dir, recursive = F), -1) all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;1 - HH_roster.csv&quot;, sep=&quot;/&quot;)) # specifying columns which are missing from the file in cols_only() causes a warning # since I can&#39;t do anything about missing columns I&#39;ve suppressed the warnings here roster &lt;- map_dfr(all_files, read_csv, col_types = cols(year = &quot;i&quot;, hhcode = &quot;d&quot;, idc = &quot;d&quot;, sex = &quot;f&quot;, age = &quot;d&quot;, spouse_idc = &quot;d&quot;, province = &quot;c&quot;, district = &quot;f&quot;, region = &quot;c&quot;)) %&gt;% mutate(year = floor_date(as.Date(as.character(year), format=&quot;%Y&quot;), unit = &quot;year&quot;), spouse_idc = as.integer(na_if(na_if(spouse_idc, 98), 99)), region = as_factor(recode(region, rural = &quot;Rural&quot;, urban = &quot;Urban&quot;)), province = as_factor(recode(province, punjab = &quot;Punjab&quot;, sindh = &quot;Sindh&quot;, nwfp = &quot;KPK&quot;, balochistan = &quot;Balochistan&quot;, NWFP = &quot;KPK&quot;, &quot;khyber pakhtunkhwa&quot; = &quot;KPK&quot;, kpk = &quot;KPK&quot;, kp = &quot;KPK&quot;)), has_spouse = !is.na(spouse_idc), age_group = cut(age, breaks = c(0, 12, 19, 30, 60, 100), labels = c(&quot;Child&quot;, &quot;Teenager&quot;, &quot;Young Adult&quot;, &quot;Adult&quot;, &quot;Senior&quot;), ordered_result = TRUE, include.lowest = TRUE)) Each individual in the survey is uniquely identified by a triplet of (year, hhcode, idc) where year is the year of survey, hhcode is household code/ID and idc is person ID within the household. There are some demographic variables telling age, sex, location of the individual. The spouse_idc column contains the ID code of the spouse of the individual (implicit fact: the spouse belongs to the same household). An NA here represents unmarried individuals. head(roster) ## # A tibble: 6 x 32 ## year hhcode province district region startum psu hhno section idc ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2004-01-01 1.00e9 Punjab islamab~ Urban 2 1.00e7 1 B 2 ## 2 2004-01-01 1.00e9 Punjab islamab~ Urban 2 1.00e7 1 B 3 ## 3 2004-01-01 1.00e9 Punjab islamab~ Urban 3 1.00e7 8 B 6 ## 4 2004-01-01 1.00e9 Punjab islamab~ Urban 3 1.00e7 7 B 6 ## 5 2004-01-01 1.00e9 Punjab islamab~ Urban 3 1.00e7 12 B 2 ## 6 2004-01-01 1.00e9 Punjab islamab~ Urban 3 1.00e7 8 B 3 ## # ... with 22 more variables: sex &lt;fct&gt;, residential_status &lt;chr&gt;, ## # relationship_w_head &lt;chr&gt;, age &lt;dbl&gt;, marital_status &lt;chr&gt;, pcode &lt;dbl&gt;, ## # weights &lt;dbl&gt;, dob_d &lt;dbl&gt;, dob_m &lt;dbl&gt;, dob_y &lt;dbl&gt;, spouse_idc &lt;int&gt;, ## # father_idc &lt;dbl&gt;, mother_idc &lt;dbl&gt;, is_hh_member &lt;chr&gt;, weight &lt;dbl&gt;, ## # hh &lt;dbl&gt;, reason_for_head &lt;chr&gt;, hhcode_new &lt;dbl&gt;, stratum &lt;dbl&gt;, ## # psu_new &lt;dbl&gt;, has_spouse &lt;lgl&gt;, age_group &lt;ord&gt; The survey follows a tick-tock pattern alternating between province and district distributed surveys. However the male/female ratio is pretty consistent around 50% which is to be expected. The majority of population lives in rural areas in Pakistan. p1 &lt;- roster %&gt;% count(year, sex) %&gt;% ggplot(aes(x = year, y = n, fill = sex)) + geom_col() + scale_y_continuous(labels = comma) + labs(title = &quot;Survey responses over time by Sex&quot;) + xlab(&quot;Survey year&quot;) + ylab(&quot;Number of individuals&quot;) p2 &lt;- roster %&gt;% count(year, region) %&gt;% group_by(year) %&gt;% mutate(pct = n / sum(n)) %&gt;% ggplot(aes(x = year, y = pct, fill = region)) + geom_col() + scale_y_continuous(labels = percent) + labs(title = &quot;Population over time by Region&quot;, subtitle = &quot;Survey sample is assumed to be population here&quot;) + xlab(&quot;Survey year&quot;) + ylab(&quot;Percentage of population&quot;) p1 + p2 Since the survey questionnaire changes across years and some questions are not asked there are some columns with significant variations in the available data. This is before considering that even if a question is asked the respondent might not provide/know the answer. roster %&gt;% group_by(year) %&gt;% summarise_all(~ mean(!is.na(.))) ## # A tibble: 13 x 32 ## year hhcode province district region startum psu hhno section idc ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2004-01-01 1 1 1 1 1 1 1 1 1 ## 2 2005-01-01 1 1 0 1 0 1 0 0 1 ## 3 2006-01-01 1 1 1 1 0 1 0 1 1 ## 4 2007-01-01 1 1 0 1 0 1 0 1 1 ## 5 2008-01-01 1 1 1 1 0 1 0 1 1 ## 6 2010-01-01 1 1 1 1 0 1 0 1 1 ## 7 2011-01-01 1 1 0 1 0 1 0 1 1 ## 8 2012-01-01 1 1 1 1 0 1 0 1 1 ## 9 2013-01-01 1 1 0 1 0 1 0 0 1 ## 10 2014-01-01 1 1 1 1 0 1 0 1 1 ## 11 2015-01-01 1 1 0 1 0 1 0 1 1 ## 12 2018-01-01 1 1 0 1 0 1 0 0 1 ## 13 2019-01-01 1 1 1 1 0 1 0 0 1 ## # ... with 22 more variables: sex &lt;dbl&gt;, residential_status &lt;dbl&gt;, ## # relationship_w_head &lt;dbl&gt;, age &lt;dbl&gt;, marital_status &lt;dbl&gt;, pcode &lt;dbl&gt;, ## # weights &lt;dbl&gt;, dob_d &lt;dbl&gt;, dob_m &lt;dbl&gt;, dob_y &lt;dbl&gt;, spouse_idc &lt;dbl&gt;, ## # father_idc &lt;dbl&gt;, mother_idc &lt;dbl&gt;, is_hh_member &lt;dbl&gt;, weight &lt;dbl&gt;, ## # hh &lt;dbl&gt;, reason_for_head &lt;dbl&gt;, hhcode_new &lt;dbl&gt;, stratum &lt;dbl&gt;, ## # psu_new &lt;dbl&gt;, has_spouse &lt;dbl&gt;, age_group &lt;dbl&gt; "],["education.html", "2 Education", " 2 Education library(tidyverse) library(lubridate) library(scales) library(patchwork) I load the education section data for each year and combine it into a single tibble/dataframe for easy analysis. There are parsing errors for some columns. I find it better to just choose the required columns for the analysis with cols_only and manually specify types for them then manually fix encoding issues. root_dir &lt;- &quot;C:/Users/R/Desktop/pslm/data_clean&quot; year_dirs &lt;- head(list.dirs(root_dir, recursive = F), -1) all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;2 - Education.csv&quot;, sep=&quot;/&quot;)) # education &lt;- map_dfr(all_files, read_csv) Each individual in the survey is uniquely identified by a triplet of (year, hhcode, idc) where year is the year of survey, hhcode is household code/ID and idc is person ID within the household. # head(education) Since the survey questionnaire changes across years and some questions are not asked there are some columns with significant variations in the available data. This is before considering that even if a question is asked the respondent might not provide/know the answer. This section is very egregious in terms of changing the survey questions (look at the literacy questions can_read/can_write etc). # education %&gt;% # group_by(year) %&gt;% # summarise_all(~ mean(!is.na(.))) "],["health.html", "3 Health", " 3 Health library(tidyverse) library(lubridate) library(scales) library(patchwork) I load the health section data for each year and combine it into a single tibble/dataframe for easy analysis. The health section was skipped in 2015s survey so I remove that filename before loading the data. There are parsing errors for some columns. I find it better to just choose the required columns for the analysis with cols_only and manually specify types for them then manually fix encoding issues. root_dir &lt;- &quot;C:/Users/R/Desktop/pslm/data_clean&quot; year_dirs &lt;- head(list.dirs(root_dir, recursive = F), -1) all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;3 - Health.csv&quot;, sep=&quot;/&quot;)) %&gt;% keep(file.exists) health &lt;- map_dfr(all_files, read_csv) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_character(), ## year = col_double(), ## hhcode = col_double(), ## startum = col_double(), ## psu = col_double(), ## hhno = col_double(), ## idc = col_double(), ## consult_times = col_double(), ## no_consult_reason_a = col_logical(), ## no_consult_reason_b = col_logical() ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_character(), ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## idc = col_double(), ## diarrhoea_days = col_double(), ## diarrhoea_motions = col_double(), ## diarrhoea_ors_water_glasses = col_double(), ## child_age_days = col_double(), ## child_age_months = col_double(), ## recent_immunization_day = col_double(), ## recent_immunization_month = col_double(), ## recent_immunization_year = col_double(), ## first_bcg_days_after_birth = col_double(), ## imminuzation_cost = col_double(), ## malaria_days = col_double(), ## malaria_treatment_else_type = col_logical() ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## province = col_character(), ## district = col_character(), ## region = col_character(), ## psu = col_double(), ## hhno = col_double(), ## idc = col_double(), ## section = col_character(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_character(), ## no_consult_reason_b = col_character(), ## unknown_question = col_character() ## ) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_character(), ## year = col_double(), ## hhcode = col_double(), ## idc = col_double(), ## diarrhoea_days = col_double(), ## diarrhoea_motions = col_double(), ## diarrhoea_ors_water_glasses = col_double(), ## child_age_days = col_double(), ## child_age_months = col_double(), ## recent_immunization_day = col_double(), ## recent_immunization_month = col_double(), ## recent_immunization_year = col_double(), ## first_bcg_days_after_birth = col_double(), ## imminuzation_cost = col_double(), ## polio_vac = col_double(), ## polio_vac1 = col_double(), ## round = col_double(), ## psu = col_double(), ## malaria_days = col_double(), ## tb_consulted = col_logical(), ## tb_consulted_type = col_logical() ## # ... with 1 more columns ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## province = col_character(), ## district = col_character(), ## region = col_character(), ## psu = col_double(), ## section = col_character(), ## idc = col_double(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_character(), ## no_consult_reason_b = col_logical(), ## lhw_visit_last_month = col_character(), ## family_visit_hu_last_month = col_character() ## ) ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## province = col_character(), ## region = col_character(), ## psu = col_double(), ## section = col_character(), ## idc = col_double(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_character(), ## no_consult_reason_b = col_logical(), ## lhw_visit_last_month = col_character(), ## family_visit_hu_last_month = col_character() ## ) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_logical(), ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## province = col_character(), ## region = col_character(), ## section = col_character(), ## idc = col_double(), ## diarrhoea_last_month = col_character(), ## diarrhoea_days = col_double(), ## diarrhoea_motions = col_double(), ## diarrhoea_still = col_character(), ## diarrhoea_consulted = col_character(), ## diarrhoea_consulted_type = col_character(), ## diarrhoea_why_private = col_character(), ## diarrhoea_why_not_govt = col_character(), ## diarrhoea_consulted_distance = col_character(), ## diarrhoea_consulted_else = col_character(), ## diarrhoea_consulted_else_type = col_character(), ## diarrhoea_ors = col_character(), ## diarrhoea_ors_where = col_character() ## # ... with 6 more columns ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## province = col_character(), ## region = col_character(), ## district = col_character(), ## psu = col_double(), ## section = col_character(), ## idc = col_double(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_character(), ## no_consult_reason_b = col_logical(), ## lhw_visit_last_month = col_character(), ## family_visit_hu_last_month = col_character() ## ) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_character(), ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## filler = col_double(), ## idc = col_double(), ## diarrhoea_days = col_double(), ## diarrhoea_motions = col_double(), ## diarrhoea_ors_water_glasses = col_double(), ## hhcode_new = col_double(), ## stratum = col_double(), ## psu_new = col_double(), ## child_age_days = col_double(), ## child_age_months = col_double(), ## recent_immunization_day = col_double(), ## recent_immunization_month = col_double(), ## recent_immunization_year = col_double(), ## first_bcg_days_after_birth = col_double(), ## imminuzation_cost = col_double(), ## respondent_idc = col_double(), ## malaria_days = col_double() ## # ... with 1 more columns ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## province = col_character(), ## region = col_character(), ## district = col_character(), ## hhno = col_double(), ## section = col_character(), ## idc = col_double(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_logical(), ## no_consult_reason_b = col_logical(), ## lhw_visit_last_month = col_character(), ## family_visit_hu_last_month = col_character() ## ) ## ## -- Column specification -------------------------------------------------------- ## cols( ## .default = col_character(), ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## idc = col_double(), ## diarrhoea_days = col_double(), ## diarrhoea_motions = col_double(), ## diarrhoea_consulted_else_type = col_logical(), ## diarrhoea_ors_water_glasses = col_double(), ## child_age_days = col_double(), ## child_age_months = col_double(), ## recent_immunization_day = col_double(), ## recent_immunization_month = col_double(), ## recent_immunization_year = col_double(), ## first_bcg_days_after_birth = col_double(), ## imminuzation_cost = col_double(), ## respondent_idc = col_double(), ## malaria_days = col_double(), ## hepatitis_precautions_what = col_logical() ## ) ## i Use `spec()` for the full column specifications. ## ## -- Column specification -------------------------------------------------------- ## cols( ## year = col_double(), ## hhcode = col_double(), ## psu = col_double(), ## province = col_character(), ## region = col_character(), ## district = col_character(), ## idc = col_double(), ## sick_last_2weeks = col_character(), ## consult = col_character(), ## consult_type = col_character(), ## consult_times = col_double(), ## consult_problems_a = col_character(), ## consult_problems_b = col_character(), ## no_consult_reason_a = col_logical(), ## no_consult_reason_b = col_logical(), ## lhw_visit_last_month = col_character(), ## family_visit_hu_last_month = col_character() ## ) Each individual in the survey is uniquely identified by a triplet of (year, hhcode, idc) where year is the year of survey, hhcode is household code/ID and idc is person ID within the household. head(health) ## # A tibble: 6 x 110 ## year hhcode province district region startum psu hhno section idc ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 1 ## 2 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 2 ## 3 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 3 ## 4 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 4 ## 5 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 5 ## 6 2004 1001100101 punjab islamabad urban 1 1.00e7 1 D 6 ## # ... with 100 more variables: sick_last_2weeks &lt;chr&gt;, consult &lt;chr&gt;, ## # consult_type &lt;chr&gt;, consult_times &lt;dbl&gt;, consult_problems_a &lt;chr&gt;, ## # consult_problems_b &lt;chr&gt;, no_consult_reason_a &lt;chr&gt;, ## # no_consult_reason_b &lt;chr&gt;, lhw_visit_last_month &lt;chr&gt;, ## # family_visit_hu_last_month &lt;chr&gt;, diarrhoea_last_month &lt;chr&gt;, ## # diarrhoea_days &lt;dbl&gt;, diarrhoea_motions &lt;dbl&gt;, diarrhoea_still &lt;chr&gt;, ## # diarrhoea_consulted &lt;chr&gt;, diarrhoea_consulted_type &lt;chr&gt;, ## # diarrhoea_why_private &lt;chr&gt;, diarrhoea_why_not_govt &lt;chr&gt;, ## # diarrhoea_consulted_distance &lt;chr&gt;, diarrhoea_consulted_else &lt;chr&gt;, ## # diarrhoea_consulted_else_type &lt;chr&gt;, diarrhoea_ors &lt;chr&gt;, ## # diarrhoea_ors_where &lt;chr&gt;, diarrhoea_ors_water_glasses &lt;dbl&gt;, ## # diarrhoea_ors_water_type &lt;chr&gt;, diarrhoea_breastfeed &lt;chr&gt;, ## # diarrhoea_food_liquid &lt;chr&gt;, diarrhoea_food_solid &lt;chr&gt;, ## # diarrhoea_food_water &lt;chr&gt;, child_age_days &lt;dbl&gt;, child_age_months &lt;dbl&gt;, ## # immunized_ever &lt;chr&gt;, immunization_card &lt;chr&gt;, immunization_bcg &lt;chr&gt;, ## # immunization_dpt_1 &lt;chr&gt;, immunization_dpt_2 &lt;chr&gt;, ## # immunization_dpt_3 &lt;chr&gt;, immunization_polio_0 &lt;chr&gt;, ## # immunization_polio_1 &lt;chr&gt;, immunization_polio_2 &lt;chr&gt;, ## # immunization_polio_3 &lt;chr&gt;, immunization_measles &lt;chr&gt;, ## # immunization_hepatitis_1 &lt;chr&gt;, immunization_hepatitis_2 &lt;chr&gt;, ## # immunization_hepatitis_3 &lt;chr&gt;, recent_immunization_where &lt;chr&gt;, ## # recent_immunization_day &lt;dbl&gt;, recent_immunization_month &lt;dbl&gt;, ## # recent_immunization_year &lt;dbl&gt;, first_bcg_days_after_birth &lt;dbl&gt;, ## # disease_inspite_a &lt;chr&gt;, disease_inspite_b &lt;chr&gt;, disease_inspite_c &lt;chr&gt;, ## # imminuzation_distance &lt;chr&gt;, imminuzation_cost &lt;dbl&gt;, ## # why_no_immunization &lt;chr&gt;, malaria_last_month &lt;chr&gt;, malaria_days &lt;dbl&gt;, ## # malaria_still_sick &lt;chr&gt;, malaria_treatment &lt;chr&gt;, ## # malaria_treatment_type &lt;chr&gt;, malaria_treatment_why_private &lt;chr&gt;, ## # malaria_treatment_why_not_govt &lt;chr&gt;, malaria_treatment_distance &lt;chr&gt;, ## # malaria_treatment_else &lt;chr&gt;, malaria_treatment_else_type &lt;chr&gt;, ## # tb_ever &lt;chr&gt;, tb_consulted &lt;chr&gt;, tb_consulted_type &lt;chr&gt;, ## # tb_consulted_distance &lt;chr&gt;, unknown_question &lt;chr&gt;, polio_vac &lt;dbl&gt;, ## # polio_vac1 &lt;dbl&gt;, round &lt;dbl&gt;, tb_last_month &lt;chr&gt;, filler &lt;dbl&gt;, ## # hhcode_new &lt;dbl&gt;, stratum &lt;dbl&gt;, psu_new &lt;dbl&gt;, immunization_penta_1 &lt;chr&gt;, ## # immunization_penta_2 &lt;chr&gt;, immunization_penta_3 &lt;chr&gt;, ## # immunization_pneumo_1 &lt;chr&gt;, immunization_pneumo_2 &lt;chr&gt;, ## # immunization_pneumo_3 &lt;chr&gt;, immunization_ipv &lt;chr&gt;, ## # immunization_measles_1 &lt;chr&gt;, immunization_measles_2 &lt;chr&gt;, ## # respondent_idc &lt;dbl&gt;, diarrhoea_last_15days &lt;chr&gt;, malaria_last_year &lt;chr&gt;, ## # malaria_treatment_when &lt;chr&gt;, malaria_symptoms &lt;chr&gt;, ## # hepatitis_last_year &lt;chr&gt;, hepatitis_last_year_type &lt;chr&gt;, ## # hepatitis_precautions &lt;chr&gt;, hepatitis_precautions_what &lt;lgl&gt;, ## # tb_last_year &lt;chr&gt;, tb_know_spread &lt;chr&gt;, tb_know_cure &lt;chr&gt; Since the survey questionnaire changes across years and some questions are not asked there are some columns with significant variations in the available data. This is before considering that even if a question is asked the respondent might not provide/know the answer. health %&gt;% group_by(year) %&gt;% summarise_all(~ mean(!is.na(.))) ## # A tibble: 12 x 110 ## year hhcode province district region startum psu hhno section idc ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2004 1 1 1 1 1 1 1 1 1 ## 2 2005 1 1 0 1 0 1 0 0 1 ## 3 2006 1 1 1 1 0 1 1 1 1 ## 4 2007 1 1 0 1 0 0.998 0 0.999 1 ## 5 2008 1 1 1 1 0 1 0 1 1 ## 6 2010 1 1 0 1 0 1 0 1 1 ## 7 2011 1 1 0 1 0 1 0 1 1 ## 8 2012 1 1 1 1 0 1 0 1 1 ## 9 2013 1 1 0 1 0 1 0 0 1 ## 10 2014 1 1 1 1 0 1 1 1 1 ## 11 2018 1 1 0 1 0 1 0 0 1.00 ## 12 2019 1 1 1 1 0 1 0 0 1 ## # ... with 100 more variables: sick_last_2weeks &lt;dbl&gt;, consult &lt;dbl&gt;, ## # consult_type &lt;dbl&gt;, consult_times &lt;dbl&gt;, consult_problems_a &lt;dbl&gt;, ## # consult_problems_b &lt;dbl&gt;, no_consult_reason_a &lt;dbl&gt;, ## # no_consult_reason_b &lt;dbl&gt;, lhw_visit_last_month &lt;dbl&gt;, ## # family_visit_hu_last_month &lt;dbl&gt;, diarrhoea_last_month &lt;dbl&gt;, ## # diarrhoea_days &lt;dbl&gt;, diarrhoea_motions &lt;dbl&gt;, diarrhoea_still &lt;dbl&gt;, ## # diarrhoea_consulted &lt;dbl&gt;, diarrhoea_consulted_type &lt;dbl&gt;, ## # diarrhoea_why_private &lt;dbl&gt;, diarrhoea_why_not_govt &lt;dbl&gt;, ## # diarrhoea_consulted_distance &lt;dbl&gt;, diarrhoea_consulted_else &lt;dbl&gt;, ## # diarrhoea_consulted_else_type &lt;dbl&gt;, diarrhoea_ors &lt;dbl&gt;, ## # diarrhoea_ors_where &lt;dbl&gt;, diarrhoea_ors_water_glasses &lt;dbl&gt;, ## # diarrhoea_ors_water_type &lt;dbl&gt;, diarrhoea_breastfeed &lt;dbl&gt;, ## # diarrhoea_food_liquid &lt;dbl&gt;, diarrhoea_food_solid &lt;dbl&gt;, ## # diarrhoea_food_water &lt;dbl&gt;, child_age_days &lt;dbl&gt;, child_age_months &lt;dbl&gt;, ## # immunized_ever &lt;dbl&gt;, immunization_card &lt;dbl&gt;, immunization_bcg &lt;dbl&gt;, ## # immunization_dpt_1 &lt;dbl&gt;, immunization_dpt_2 &lt;dbl&gt;, ## # immunization_dpt_3 &lt;dbl&gt;, immunization_polio_0 &lt;dbl&gt;, ## # immunization_polio_1 &lt;dbl&gt;, immunization_polio_2 &lt;dbl&gt;, ## # immunization_polio_3 &lt;dbl&gt;, immunization_measles &lt;dbl&gt;, ## # immunization_hepatitis_1 &lt;dbl&gt;, immunization_hepatitis_2 &lt;dbl&gt;, ## # immunization_hepatitis_3 &lt;dbl&gt;, recent_immunization_where &lt;dbl&gt;, ## # recent_immunization_day &lt;dbl&gt;, recent_immunization_month &lt;dbl&gt;, ## # recent_immunization_year &lt;dbl&gt;, first_bcg_days_after_birth &lt;dbl&gt;, ## # disease_inspite_a &lt;dbl&gt;, disease_inspite_b &lt;dbl&gt;, disease_inspite_c &lt;dbl&gt;, ## # imminuzation_distance &lt;dbl&gt;, imminuzation_cost &lt;dbl&gt;, ## # why_no_immunization &lt;dbl&gt;, malaria_last_month &lt;dbl&gt;, malaria_days &lt;dbl&gt;, ## # malaria_still_sick &lt;dbl&gt;, malaria_treatment &lt;dbl&gt;, ## # malaria_treatment_type &lt;dbl&gt;, malaria_treatment_why_private &lt;dbl&gt;, ## # malaria_treatment_why_not_govt &lt;dbl&gt;, malaria_treatment_distance &lt;dbl&gt;, ## # malaria_treatment_else &lt;dbl&gt;, malaria_treatment_else_type &lt;dbl&gt;, ## # tb_ever &lt;dbl&gt;, tb_consulted &lt;dbl&gt;, tb_consulted_type &lt;dbl&gt;, ## # tb_consulted_distance &lt;dbl&gt;, unknown_question &lt;dbl&gt;, polio_vac &lt;dbl&gt;, ## # polio_vac1 &lt;dbl&gt;, round &lt;dbl&gt;, tb_last_month &lt;dbl&gt;, filler &lt;dbl&gt;, ## # hhcode_new &lt;dbl&gt;, stratum &lt;dbl&gt;, psu_new &lt;dbl&gt;, immunization_penta_1 &lt;dbl&gt;, ## # immunization_penta_2 &lt;dbl&gt;, immunization_penta_3 &lt;dbl&gt;, ## # immunization_pneumo_1 &lt;dbl&gt;, immunization_pneumo_2 &lt;dbl&gt;, ## # immunization_pneumo_3 &lt;dbl&gt;, immunization_ipv &lt;dbl&gt;, ## # immunization_measles_1 &lt;dbl&gt;, immunization_measles_2 &lt;dbl&gt;, ## # respondent_idc &lt;dbl&gt;, diarrhoea_last_15days &lt;dbl&gt;, malaria_last_year &lt;dbl&gt;, ## # malaria_treatment_when &lt;dbl&gt;, malaria_symptoms &lt;dbl&gt;, ## # hepatitis_last_year &lt;dbl&gt;, hepatitis_last_year_type &lt;dbl&gt;, ## # hepatitis_precautions &lt;dbl&gt;, hepatitis_precautions_what &lt;dbl&gt;, ## # tb_last_year &lt;dbl&gt;, tb_know_spread &lt;dbl&gt;, tb_know_cure &lt;dbl&gt; "],["employment.html", "4 Employment", " 4 Employment library(tidyverse) library(lubridate) library(scales) library(patchwork) I load the employment section data for each year and combine it into a single tibble/dataframe for easy analysis. There are parsing errors for some columns. I find it better to just choose the required columns for the analysis with cols_only and manually specify types for them then manually fix encoding issues. root_dir &lt;- &quot;C:/Users/R/Desktop/pslm/data_clean&quot; year_dirs &lt;- head(list.dirs(root_dir, recursive = F), -1) all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;4 - Employment.csv&quot;, sep=&quot;/&quot;)) %&gt;% keep(file.exists) # employment &lt;- map_dfr(all_files, read_csv) Each individual in the survey is uniquely identified by a triplet of (year, hhcode, idc) where year is the year of survey, hhcode is household code/ID and idc is person ID within the household. # head(employment) Since the survey questionnaire changes across years and some questions are not asked there are some columns with significant variations in the available data. This is before considering that even if a question is asked the respondent might not provide/know the answer. # employment %&gt;% # group_by(year) %&gt;% # summarise_all(~ mean(!is.na(.))) "],["marriages-in-pakistan.html", "5 Marriages in Pakistan 5.1 Underage marriages 5.2 Age-gap in couples 5.3 Income-gap in couples", " 5 Marriages in Pakistan There are many well-known problems regarding marriages in Pakistan like child marriage, forced marriage etc. I want to investigate these phenomenon through simple analysis of the Pakistan Social And Living Standards Measurement Survey (PSLM). This is the most frequent and up-to-date demographic survey conducted in Pakistan with sufficient detail to allow interesting explorations through the data. I will be using R/tidyverse for the rest of the analysis. library(tidyverse) library(lubridate) library(scales) library(patchwork) library(ggrepel) library(ggforce) I load the survey roster data for each year and combine it into a single tibble/dataframe for easy analysis. There are a lot of columns which I dont plan to use for this analysis so I just read the relevant ones in the appropriate datatypes also there are encoding issues in this table and some columns are missing from certain years. I cant do much about the missing columns but I manually fix inconsistent encoding in factor columns and set certain sentinel values to NA using information from the questionnaire pdf. I also create a has_spouse column which I will extensively use for the analysis as a simplification of marital status which usually contains other statuses like divorced, engaged etc. Similarly I make an age_group column to group analyses/plots later. root_dir &lt;- &quot;C:/Users/R/Desktop/pslm/data_clean&quot; year_dirs &lt;- head(list.dirs(root_dir, recursive = F), -1) all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;1 - HH_roster.csv&quot;, sep=&quot;/&quot;)) # specifying columns which are missing from the file in cols_only() causes a warning # since I can&#39;t do anything about missing columns I&#39;ve suppressed the warnings here roster &lt;- map_dfr(all_files, read_csv, col_types = cols_only(year = &quot;i&quot;, hhcode = &quot;d&quot;, idc = &quot;d&quot;, sex = &quot;f&quot;, age = &quot;d&quot;, spouse_idc = &quot;d&quot;, province = &quot;c&quot;, district = &quot;f&quot;, region = &quot;c&quot;)) %&gt;% mutate(year = floor_date(as.Date(as.character(year), format=&quot;%Y&quot;), unit = &quot;year&quot;), spouse_idc = as.integer(na_if(na_if(spouse_idc, 98), 99)), region = as_factor(recode(region, rural = &quot;Rural&quot;, urban = &quot;Urban&quot;)), province = as_factor(recode(province, punjab = &quot;Punjab&quot;, sindh = &quot;Sindh&quot;, nwfp = &quot;KPK&quot;, balochistan = &quot;Balochistan&quot;, NWFP = &quot;KPK&quot;, &quot;khyber pakhtunkhwa&quot; = &quot;KPK&quot;, kpk = &quot;KPK&quot;, kp = &quot;KPK&quot;)), has_spouse = !is.na(spouse_idc), age_group = cut(age, breaks = c(0, 12, 19, 30, 60, 100), labels = c(&quot;Child&quot;, &quot;Teenager&quot;, &quot;Young Adult&quot;, &quot;Adult&quot;, &quot;Senior&quot;), ordered_result = TRUE, include.lowest = TRUE)) Each individual in the survey is uniquely identified by a triplet of (year, hhcode, idc) where year is the year of survey, hhcode is household code/ID and idc is person ID within the household. There are some demographic variables telling age, sex, location of the individual. The spouse_idc column contains the ID code of the spouse of the individual (implicit fact: the spouse belongs to the same household). An NA here represents unmarried individuals. head(roster) ## # A tibble: 6 x 11 ## year hhcode province district region idc sex age spouse_idc ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2004-01-01 1001200501 Punjab islamabad Urban 2 male 27 NA ## 2 2004-01-01 1001200501 Punjab islamabad Urban 3 male 25 NA ## 3 2004-01-01 1001300108 Punjab islamabad Urban 6 male 34 NA ## 4 2004-01-01 1001300207 Punjab islamabad Urban 6 male 26 NA ## 5 2004-01-01 1001300212 Punjab islamabad Urban 2 male 70 NA ## 6 2004-01-01 1001300308 Punjab islamabad Urban 3 male 40 NA ## # ... with 2 more variables: has_spouse &lt;lgl&gt;, age_group &lt;ord&gt; To see the number of married individuals I need to choose a single gender in order to avoid double counting since marriage is a symmetric relationship. It seems like there were no married people in 2004 and 2008 but this is obviously incorrect. The survey questionnaire did not contain a field for spouse_idc in these years. While we can use the marital_status column I have chosen to skip these years since I need the spouse_idc for the couple-level analysis I want to do. roster %&gt;% filter(sex == &quot;male&quot;) %&gt;% count(year, has_spouse) %&gt;% group_by(year) %&gt;% mutate(pct = n / sum(n)) %&gt;% ggplot(aes(x = year, y = pct, fill = has_spouse)) + geom_col() + # scale_x_date(breaks = date_ticks, date_labels = &quot;%Y&quot;) + scale_y_continuous(labels = percent) + labs(title = &quot;Marital Status over time&quot;) + xlab(&quot;Survey year&quot;) + ylab(&quot;Percentage of married individuals&quot;) 5.1 Underage marriages I want to see the youngest married individuals in each year. This looks very alarming since there are a lot of children with spouses in the dataset. Even more shocking is that none of the youngest married individuals are over the legal marriage age of 18. roster %&gt;% filter(has_spouse) %&gt;% group_by(year, region, sex) %&gt;% summarise(age = min(age)) %&gt;% ggplot(aes(x = year, y = age, color = sex, shape = sex)) + geom_point(size = 5) + facet_wrap(~region) + # scale_x_date(breaks = date_ticks, date_labels = &quot;%Y&quot;) + labs(title = &quot;Youngest married individuals&quot;) + xlab(&quot;Survey year&quot;) + ylab(&quot;Age&quot;) In the numbers for just underage married individuals very few are below the age of 12 (children) and majority are in their teens (up to 17 only). roster %&gt;% filter(has_spouse, age &lt; 18) %&gt;% count(year, age_group) %&gt;% ggplot(aes(x = year, y = n, fill = age_group)) + geom_col() + # scale_x_date(breaks = date_ticks, date_labels = &quot;%Y&quot;) + labs(title = &quot;Number of underage married individuals&quot;) + xlab(&quot;Survey year&quot;) + ylab(&quot;Number of individuals&quot;) 5.2 Age-gap in couples Now I will create couple pairings using idc and spouse_idc columns from the roster. At this point my unit-of-analysis is a couple instead of an individual so one row in my dataframe should correspond to one couple. This causes repetitive names since each couple contains two individuals. The variable of interest here is age_gap which shows how much older the husband is compared to the wife. males &lt;- roster %&gt;% filter(has_spouse, sex == &quot;male&quot;) females &lt;- roster %&gt;% filter(has_spouse, sex == &quot;female&quot;) couples &lt;- males %&gt;% inner_join(females, by = c(&quot;spouse_idc&quot; = &quot;idc&quot;, &quot;hhcode&quot; = &quot;hhcode&quot;, &quot;year&quot; = &quot;year&quot;), suffix = c(&quot;.husband&quot;, &quot;.wife&quot;)) %&gt;% mutate(age_gap = age.husband - age.wife) %&gt;% rename(province = province.husband, district = district.husband, region = region.husband, idc.husband = idc, idc.wife = spouse_idc) %&gt;% select(-province.wife, -district.wife, -region.wife, -sex.husband, -sex.wife, -has_spouse.husband, -has_spouse.wife, -spouse_idc.wife) %&gt;% select(year, hhcode, province, district, region, idc.husband, age.husband, age_group.husband, idc.wife, age.wife, age_group.wife, age_gap) # temporary tables removed after use to free up memory rm(males, females) head(couples) ## # A tibble: 6 x 12 ## year hhcode province district region idc.husband age.husband ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2005-01-01 1011010101 Punjab &lt;NA&gt; Urban 1 64 ## 2 2005-01-01 1011010102 Punjab &lt;NA&gt; Urban 1 35 ## 3 2005-01-01 1011010103 Punjab &lt;NA&gt; Urban 1 70 ## 4 2005-01-01 1011010104 Punjab &lt;NA&gt; Urban 1 40 ## 5 2005-01-01 1011010105 Punjab &lt;NA&gt; Urban 1 49 ## 6 2005-01-01 1011010106 Punjab &lt;NA&gt; Urban 1 30 ## # ... with 5 more variables: age_group.husband &lt;ord&gt;, idc.wife &lt;dbl&gt;, ## # age.wife &lt;dbl&gt;, age_group.wife &lt;ord&gt;, age_gap &lt;dbl&gt; The first thing I want to see is if there is any correlation between the ages of spouses. There appears to be a near-perfect linear trend as seen with the reference diagonal line (representing no age gap). Most of the points are to the lower-right of the line meaning most couples have a slightly older husband. An interesting thing to note here is that there are more men with the max age (99) than women. In the questionnaire age over 100 is supposed to be represented as 99. There are more outliers with large age gaps in the lower-right triangle than in the upper-left one. This means that where are more couples where the husband is older than the wife. There also seem to be more couples with older husbands in rural region. ggplot(couples, aes(x = age.husband, y = age.wife)) + geom_point(aes(color = abs(age_gap) &gt; 30), alpha = 0.1) + scale_color_manual(values = c(&quot;#C3C3C3&quot;, &quot;#198D8D&quot;)) + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + coord_fixed() + facet_wrap(~ region) + xlab(&quot;Husband&#39;s age&quot;) + ylab(&quot;Wife&#39;s age&quot;) avg by district couples %&gt;% group_by(region, district) %&gt;% summarise(avg_age.husband = median(age.husband), avg_age.wife = median(age.wife)) %&gt;% ggplot(aes(x = avg_age.husband, y = avg_age.wife, color = region)) + geom_jitter() + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + coord_fixed() + xlab(&quot;Average husband&#39;s age&quot;) + ylab(&quot;Average wife&#39;s age&quot;) The distribution of age gap over the years has remained pretty consistent. The age gap for rural couples is much more tightly distributed around the mean than the urban even though in the previous chart we saw that rural region has more extreme values (this isnt visible in this chart because of small scale). ggplot(couples, aes(x = age_gap, y = after_stat(density), fill = region)) + geom_histogram(binwidth = 5, alpha = 0.5) + facet_wrap(~ year) + labs(title = &quot;Distribution of Age gap by Year and Region&quot;, subtitle = &quot;Positive gap denotes older husband and vice versa&quot;) + xlab(&quot;Age gap&quot;) Since there are no differences across years we can ignore that dimension and look more closely at differences across regions. In both regions the median is positive most couples have a slightly older husband. The rural region does indeed have a tighter distribution around 0 but it also has more extreme cases. Qualitatively, it seems like in rural areas it is much more likely to have a partner almost exactly the same age as you or to have a much older husband (more common) or wife (less common). median_gap_by_region &lt;- couples %&gt;% group_by(region) %&gt;% summarise(med = median(age_gap)) %&gt;% mutate(label = str_c(&#39;Median:&#39;, format(med, nsmall = 1))) ggplot() + geom_boxplot(data = couples, mapping = aes(x = age_gap, y = region, color = region), show.legend = FALSE) + geom_label_repel(data = median_gap_by_region, mapping = aes(x = med, y = region, label = label)) + labs(title = &quot;Distribution of Age gap by Region&quot;, subtitle = &quot;Positive gap denotes older husband and vice versa&quot;) + xlab(&quot;Age gap&quot;) + ylab(&quot;Region&quot;) 5.3 Income-gap in couples Lets load the income data from PSLM files as well. Since this is just an illustrative exercise for simplicity I am only looking at reported annual cash income. all_files &lt;- map(year_dirs, function(year_dir) paste(year_dir, &quot;4 - Employment.csv&quot;, sep=&quot;/&quot;)) # specifying columns which are missing from the file in cols_only() causes a warning # since I can&#39;t do anything about missing columns I&#39;ve suppressed the warnings here income &lt;- map_dfr(all_files, read_csv, col_types = cols_only(year = &quot;i&quot;, hhcode = &quot;d&quot;, idc = &quot;d&quot;, province = &quot;c&quot;, region = &quot;c&quot;, work1_occupation = &quot;c&quot;, work1_industry = &quot;c&quot;, work1_income_last_month = &quot;d&quot;, work1_months_worked_last_year = &quot;d&quot;, work1_income_last_year = &quot;d&quot;, work2_income_last_year = &quot;d&quot;, other_work_income_last_year = &quot;d&quot;, in_kind_income = &quot;d&quot;, pension_income = &quot;d&quot;, remittance_within_pak = &quot;d&quot;, remittance_outside_pak = &quot;d&quot;, property_rent_recieved = &quot;d&quot;, other_income_without_economic_activity = &quot;d&quot;)) %&gt;% mutate(year = floor_date(as.Date(as.character(year), format=&quot;%Y&quot;), unit = &quot;year&quot;), region = as_factor(recode(region, rural = &quot;Rural&quot;, urban = &quot;Urban&quot;)), province = as_factor(recode(province, punjab = &quot;Punjab&quot;, sindh = &quot;Sindh&quot;, nwfp = &quot;KPK&quot;, balochistan = &quot;Balochistan&quot;, NWFP = &quot;KPK&quot;, &quot;khyber pakhtunkhwa&quot; = &quot;KPK&quot;, kpk = &quot;KPK&quot;, kp = &quot;KPK&quot;, gilgit = &quot;Gilgit&quot;)), work1_income_last_year.calc = work1_income_last_month * work1_income_last_month, work1_income_last_year.combined = pmax(work1_income_last_year, work1_income_last_year.calc), work1_occupation = as_factor(str_to_sentence(work1_occupation)), work1_industry = as_factor(str_to_sentence(work1_industry)) ) %&gt;% mutate_if(is.numeric , replace_na, replace = 0) %&gt;% mutate(total_annual_income = (work1_income_last_year.combined + work2_income_last_year + other_work_income_last_year + in_kind_income + pension_income + remittance_within_pak + remittance_outside_pak + property_rent_recieved + other_income_without_economic_activity)) head(income) ## # A tibble: 6 x 21 ## year hhcode province region idc work1_occupation work1_industry ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 2004-01-01 1.00e9 Punjab Urban 1 Service, shop , sal~ Social &amp; person~ ## 2 2004-01-01 1.00e9 Punjab Urban 2 Service, shop , sal~ Social &amp; person~ ## 3 2004-01-01 1.00e9 Punjab Urban 3 &lt;NA&gt; &lt;NA&gt; ## 4 2004-01-01 1.00e9 Punjab Urban 4 &lt;NA&gt; &lt;NA&gt; ## 5 2004-01-01 1.00e9 Punjab Urban 1 Service, shop , sal~ Social &amp; person~ ## 6 2004-01-01 1.00e9 Punjab Urban 2 &lt;NA&gt; &lt;NA&gt; ## # ... with 14 more variables: work1_income_last_month &lt;dbl&gt;, ## # work1_months_worked_last_year &lt;dbl&gt;, work1_income_last_year &lt;dbl&gt;, ## # work2_income_last_year &lt;dbl&gt;, other_work_income_last_year &lt;dbl&gt;, ## # in_kind_income &lt;dbl&gt;, pension_income &lt;dbl&gt;, remittance_within_pak &lt;dbl&gt;, ## # remittance_outside_pak &lt;dbl&gt;, property_rent_recieved &lt;dbl&gt;, ## # other_income_without_economic_activity &lt;dbl&gt;, ## # work1_income_last_year.calc &lt;dbl&gt;, work1_income_last_year.combined &lt;dbl&gt;, ## # total_annual_income &lt;dbl&gt; distribution of total income income %&gt;% ggplot(aes(total_annual_income)) + geom_histogram() + scale_x_log10(labels = comma) ## Warning: Transformation introduced infinite values in continuous x-axis ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 2982251 rows containing non-finite values (stat_bin). plot_categorical_count &lt;- function(tbl, cat_col, n_levels = 10) { result &lt;- tbl %&gt;% filter(!is.na({{ cat_col }})) %&gt;% mutate({{ cat_col }} := fct_lump_n({{ cat_col }}, n_levels)) %&gt;% group_by({{ cat_col }}, region) %&gt;% summarize(aggregated = n()) %&gt;% ungroup() %&gt;% mutate({{ cat_col }} := fct_reorder({{ cat_col }}, aggregated)) result %&gt;% ggplot(aes(aggregated, {{ cat_col }}, fill = region)) + geom_col() + scale_x_continuous(labels = label_comma()) } income %&gt;% plot_categorical_count(work1_occupation, 15) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Number of people by Occupation&quot;) income %&gt;% plot_categorical_count(work1_industry, 15) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Number of people by Industry&quot;) plot_categorical_summary &lt;- function(tbl, cat_col, n_levels = 10, agg_col, agg_fun) { result &lt;- tbl %&gt;% filter(!is.na({{ cat_col }})) %&gt;% mutate({{ cat_col }} := fct_lump_n({{ cat_col }}, n_levels)) %&gt;% group_by({{ cat_col }}, region) %&gt;% summarize(aggregated = agg_fun({{ agg_col }})) %&gt;% ungroup() %&gt;% mutate({{ cat_col }} := fct_reorder({{ cat_col }}, aggregated)) result %&gt;% ggplot(aes(aggregated, {{ cat_col }}, fill = region)) + geom_col() + scale_x_continuous(labels = label_comma()) } income %&gt;% plot_categorical_summary(work1_occupation, 15, total_annual_income, mean) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Mean annual income by Occupation&quot;) ## `summarise()` has grouped output by &#39;work1_occupation&#39;. You can override using the `.groups` argument. income %&gt;% plot_categorical_summary(work1_industry, 15, total_annual_income, mean) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Mean annual income by Industry&quot;) ## `summarise()` has grouped output by &#39;work1_industry&#39;. You can override using the `.groups` argument. income over time income %&gt;% filter(!is.na(total_annual_income)) %&gt;% ggplot(aes(x = year, y = total_annual_income, group = interaction(year, region), fill = region)) + geom_boxplot() + scale_y_log10(labels = label_comma()) + labs(x = &quot;&quot;, y = &quot;Annual Income (PKR)&quot;) ## Warning: Transformation introduced infinite values in continuous y-axis ## Warning: Removed 2982251 rows containing non-finite values (stat_boxplot). income over time married/unmarried by sex roster_enriched &lt;- roster %&gt;% left_join(income %&gt;% select(year,hhcode,idc,total_annual_income,work1_occupation,work1_industry),by = c(&quot;year&quot;,&quot;hhcode&quot;,&quot;idc&quot;)) head(roster_enriched) ## # A tibble: 6 x 14 ## year hhcode province district region idc sex age spouse_idc ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2004-01-01 1001200501 Punjab islamabad Urban 2 male 27 NA ## 2 2004-01-01 1001200501 Punjab islamabad Urban 3 male 25 NA ## 3 2004-01-01 1001300108 Punjab islamabad Urban 6 male 34 NA ## 4 2004-01-01 1001300207 Punjab islamabad Urban 6 male 26 NA ## 5 2004-01-01 1001300212 Punjab islamabad Urban 2 male 70 NA ## 6 2004-01-01 1001300308 Punjab islamabad Urban 3 male 40 NA ## # ... with 5 more variables: has_spouse &lt;lgl&gt;, age_group &lt;ord&gt;, ## # total_annual_income &lt;dbl&gt;, work1_occupation &lt;fct&gt;, work1_industry &lt;fct&gt; There is a slight bimodal pattern in the income distribution. roster_enriched %&gt;% ggplot(aes(total_annual_income, fill = region)) + geom_histogram(position = &quot;identity&quot;, alpha = 0.5) + scale_x_log10(labels = comma) ## Warning: Transformation introduced infinite values in continuous x-axis ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 4281976 rows containing non-finite values (stat_bin). effect of age and marriage on income. The second mode is significantly stronger in unmarried rural people. roster_enriched %&gt;% filter(!is.na(total_annual_income), total_annual_income &gt; 0, !is.na(age)) %&gt;% ggplot(aes(x = age, y = total_annual_income, color = has_spouse)) + geom_mark_ellipse(aes(filter = between(total_annual_income, 50, 1000) &amp; between(age, 20, 80)), color = &quot;black&quot;) + geom_point(alpha = 0.1) + scale_y_log10(labels = label_comma()) + guides(color = guide_legend(override.aes = list(alpha = 1))) + facet_grid(has_spouse ~ region) + labs(x = &quot;Age&quot;, y = &quot;Annual Income (PKR)&quot;, color = &quot;Married?&quot;) Looking at different dimensions men are the majority of the second mode. roster_enriched %&gt;% filter(!is.na(total_annual_income), total_annual_income &gt; 0, !is.na(age)) %&gt;% ggplot(aes(x = age, y = total_annual_income, color = has_spouse)) + geom_mark_ellipse(aes(filter = between(total_annual_income, 50, 1000) &amp; between(age, 20, 80)), color = &quot;black&quot;) + geom_point(alpha = 0.1) + scale_y_log10(labels = label_comma()) + guides(color = guide_legend(override.aes = list(alpha = 1))) + facet_grid(has_spouse ~ sex) + labs(x = &quot;Age&quot;, y = &quot;Annual Income (PKR)&quot;, color = &quot;Married?&quot;) Looking at the most common industries the second mode is basically only present in agriculture. roster_enriched %&gt;% filter(!is.na(total_annual_income), total_annual_income &gt; 0, !is.na(age), !has_spouse, sex == &quot;male&quot;, !is.na(work1_industry), region == &quot;Rural&quot;) %&gt;% mutate(work1_industry = fct_lump_n(work1_industry, 8)) %&gt;% ggplot(aes(x = age, y = total_annual_income, color = work1_industry)) + geom_mark_ellipse(aes(filter = between(total_annual_income, 50, 1000) &amp; between(age, 20, 80)), color = &quot;black&quot;) + geom_point(alpha = 0.1) + scale_y_log10(labels = label_comma()) + theme(legend.position = &quot;none&quot;) + # guides(color = guide_legend(override.aes = list(alpha = 1))) + facet_wrap(~work1_industry) + labs(x = &quot;Age&quot;, y = &quot;Annual Income (PKR)&quot;) Within agriculture basically only 1 occupation is responsible for the mode. There is a trend in agricultural communities for workers to be paid in form of room and board instead of cash. If I had loaded the other payment types then I could have verified this hypothesis. roster_enriched %&gt;% filter(!is.na(total_annual_income), total_annual_income &gt; 0, !is.na(age), !has_spouse, sex == &quot;male&quot;, !is.na(work1_industry), region == &quot;Rural&quot;, work1_industry == &quot;Agriculture, forestry, fishing&quot;) %&gt;% mutate(work1_occupation = fct_lump_n(work1_occupation, 8)) %&gt;% ggplot(aes(x = age, y = total_annual_income, color = work1_occupation)) + geom_mark_ellipse(aes(filter = between(total_annual_income, 50, 1000) &amp; between(age, 20, 80)), color = &quot;black&quot;) + geom_point(alpha = 0.1) + scale_y_log10(labels = label_comma()) + theme(legend.position = &quot;none&quot;) + # guides(color = guide_legend(override.aes = list(alpha = 1))) + facet_wrap(~work1_occupation) + labs(x = &quot;Age&quot;, y = &quot;Annual Income (PKR)&quot;) roster_enriched %&gt;% filter(!is.na(total_annual_income), total_annual_income &gt; 0, !is.na(age), !has_spouse, sex == &quot;male&quot;, !is.na(work1_industry), region == &quot;Rural&quot;, work1_industry == &quot;Other&quot;) %&gt;% mutate(work1_occupation = fct_lump_n(work1_occupation, 8)) %&gt;% ggplot(aes(x = age, y = total_annual_income, color = work1_occupation)) + geom_mark_ellipse(aes(filter = between(total_annual_income, 50, 1000) &amp; between(age, 20, 80)), color = &quot;black&quot;) + geom_point(alpha = 0.1) + scale_y_log10(labels = label_comma()) + theme(legend.position = &quot;none&quot;) + # guides(color = guide_legend(override.aes = list(alpha = 1))) + facet_wrap(~work1_occupation) + labs(x = &quot;Age&quot;, y = &quot;Annual Income (PKR)&quot;) It appears the effect of marraige on income is reversed for men and women. (TODO: check this using a model) roster_enriched %&gt;% filter(!is.na(total_annual_income)) %&gt;% ggplot(aes(x = year, y = total_annual_income, group = interaction(year, has_spouse), fill = has_spouse)) + geom_boxplot() + scale_y_log10(labels = label_comma()) + facet_wrap(~sex) + labs(x = &quot;&quot;, y = &quot;Annual Income (PKR)&quot;) ## Warning: Transformation introduced infinite values in continuous y-axis ## Warning: Removed 2981689 rows containing non-finite values (stat_boxplot). income of couples couples_enriched &lt;- couples %&gt;% left_join(income %&gt;% select(year,hhcode,idc,total_annual_income) %&gt;% rename(annual_income.husband = total_annual_income), by = c(&quot;year&quot;, &quot;hhcode&quot;, &quot;idc.husband&quot; = &quot;idc&quot;)) %&gt;% left_join(income %&gt;% select(year,hhcode,idc,total_annual_income) %&gt;% rename(annual_income.wife = total_annual_income), by = c(&quot;year&quot;, &quot;hhcode&quot;, &quot;idc.wife&quot; = &quot;idc&quot;)) %&gt;% mutate(annual_income_gap = annual_income.husband - annual_income.wife, is_earning.husband = (annual_income.husband &gt; 0) &amp; (!is.na(annual_income.husband)), is_earning.wife = (annual_income.wife &gt; 0) &amp; (!is.na(annual_income.wife)), who_earns = case_when(is_earning.husband &amp; is_earning.wife ~ &quot;Both&quot;, is_earning.husband &amp; !is_earning.wife ~ &quot;Husband only&quot;, !is_earning.husband &amp; is_earning.wife ~ &quot;Wife only&quot;, !is_earning.husband &amp; !is_earning.wife ~ &quot;Neither&quot;), who_earns = fct_relevel(as_factor(who_earns), &quot;Both&quot;,&quot;Husband only&quot;,&quot;Wife only&quot;,&quot;Neither&quot;)) %&gt;% select(year, hhcode, province, district, region, idc.husband, age.husband, age_group.husband, annual_income.husband, idc.wife, age.wife, age_group.wife, annual_income.wife, age_gap, annual_income_gap, who_earns) head(couples_enriched) ## # A tibble: 6 x 16 ## year hhcode province district region idc.husband age.husband ## &lt;date&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2005-01-01 1011010101 Punjab &lt;NA&gt; Urban 1 64 ## 2 2005-01-01 1011010102 Punjab &lt;NA&gt; Urban 1 35 ## 3 2005-01-01 1011010103 Punjab &lt;NA&gt; Urban 1 70 ## 4 2005-01-01 1011010104 Punjab &lt;NA&gt; Urban 1 40 ## 5 2005-01-01 1011010105 Punjab &lt;NA&gt; Urban 1 49 ## 6 2005-01-01 1011010106 Punjab &lt;NA&gt; Urban 1 30 ## # ... with 9 more variables: age_group.husband &lt;ord&gt;, ## # annual_income.husband &lt;dbl&gt;, idc.wife &lt;dbl&gt;, age.wife &lt;dbl&gt;, ## # age_group.wife &lt;ord&gt;, annual_income.wife &lt;dbl&gt;, age_gap &lt;dbl&gt;, ## # annual_income_gap &lt;dbl&gt;, who_earns &lt;fct&gt; who earns couples_enriched %&gt;% count(year, region, who_earns) %&gt;% group_by(year, region) %&gt;% mutate(pct = n / sum(n)) %&gt;% ungroup() %&gt;% mutate(who_earns = fct_reorder(who_earns, n)) %&gt;% ggplot(aes(x = year, y = pct, fill = who_earns)) + geom_col() + scale_y_continuous(labels = label_percent()) + facet_wrap(~region) + labs(x = &quot;&quot;, y = &quot;Percentage of couples&quot;, title = &quot;Who earns in a marriage?&quot;, color = &quot;&quot;) dist of income gap couples_enriched %&gt;% ggplot(aes(x = annual_income_gap)) + geom_histogram() + scale_x_log10(label = label_comma()) + facet_wrap(~ who_earns, scales = &quot;free&quot;) ## Warning in self$trans$transform(x): NaNs produced ## Warning: Transformation introduced infinite values in continuous x-axis ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 394887 rows containing non-finite values (stat_bin). couple correlation couples_enriched %&gt;% # filter(who_earns == &quot;Both&quot;) %&gt;% ggplot(aes(x = annual_income.husband, y = annual_income.wife)) + geom_point(aes(color = abs(annual_income_gap) &gt; 100000), alpha = 0.1) + scale_color_manual(values = c(&quot;#C3C3C3&quot;, &quot;#198D8D&quot;)) + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + scale_x_log10(labels = label_comma()) + scale_y_log10(labels = label_comma()) + coord_fixed() + facet_wrap(~ region) + guides(color = guide_legend(override.aes = list(alpha = 1))) + labs(x = &quot;Husband&#39;s annual income&quot;, y = &quot;Wife&#39;s annual income&quot;, color = &quot;Annual income gap &gt; 1 lakh PKR&quot;) ## Warning: Transformation introduced infinite values in continuous x-axis ## Warning: Transformation introduced infinite values in continuous y-axis ## Warning: Removed 533 rows containing missing values (geom_point). correlation of income gap with age gap couples_enriched %&gt;% # filter(who_earns != &quot;Neither&quot;) %&gt;% filter(who_earns == &quot;Both&quot;) %&gt;% mutate(ag.h = ntile(age.husband, 4), ag.w = ntile(age.wife, 4)) %&gt;% ggplot(aes(x = age_gap, y = annual_income_gap, color = region)) + geom_point(alpha = 0.1) + # geom_smooth() + # scale_color_manual(values = c(&quot;#C3C3C3&quot;, &quot;#198D8D&quot;)) + # geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + # scale_x_log10(labels = label_comma()) + scale_y_log10(labels = label_comma()) + guides(color = guide_legend(override.aes = list(alpha = 1))) + # coord_fixed() +&#39; # facet_wrap(~ region) + # facet_grid(ag.w ~ ag.h) + labs(x = &quot;Age gap&quot;, y = &quot;Annual income gap (PKR)&quot;) ## Warning in self$trans$transform(x): NaNs produced ## Warning: Transformation introduced infinite values in continuous y-axis ## Warning: Removed 1146 rows containing missing values (geom_point). "]]
